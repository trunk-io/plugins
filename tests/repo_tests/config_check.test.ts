import * as fs from "fs";
import path from "path";
import { setupDriver } from "tests";
import { REPO_ROOT } from "tests/utils";

// Avoid strictly typing composite config
// trunk-ignore-all(eslint/@typescript-eslint/no-unsafe-assignment)
// trunk-ignore-all(eslint/@typescript-eslint/no-unsafe-member-access)
// trunk-ignore-all(eslint/@typescript-eslint/no-unsafe-call)
// trunk-ignore-all(eslint/@typescript-eslint/no-unsafe-argument)

/**
 * This test runs 'trunk config print' from the root of the repository to verify a healthy config.
 * This serves as a general, basic healthcheck and asserts that all definitions resolve correctly,
 * even in the context of each other. If this test were to fail, users would experience config errors
 * when sourcing plugins from this repository.
 *
 * This test also validates that only explicitly enumerated linters are recommended by default.
 */
describe("Global config health check", () => {
  // Step 1: Define test setup and teardown
  const driver = setupDriver(REPO_ROOT, {
    setupGit: false,
    setupTrunk: true,
  });

  // Step 2a: Validate config
  it("trunk config print from repo root", async () => {
    // Remove user.yaml if it exists, since some definitions may not exist in composite config.
    // Specifying force avoid errors being thrown if it doesn't exist.
    fs.rmSync(path.resolve(driver.getSandbox(), ".trunk/user.yaml"), {
      force: true,
    });

    // Test that config healthily resolves
    const testRunResult = await driver.run("config print");
    expect(testRunResult.stdout).toContain("version: 0.1");
    expect(testRunResult.stdout).toContain("local:");
  });

  // Step 2b: Validate only verified linters are auto-enabled
  it("validate auto-enabled linters", async () => {
    const compositeYaml = await driver.getFullTrunkConfig();
    const allLinterDefinitions = compositeYaml.lint.definitions;

    // Generate list of auto-enabled linters based on config and repo setup.
    const autoEnabledLinters = allLinterDefinitions.reduce(
      (accumulator: string[], linterDefinition: any) => {
        const localRelativePath = linterDefinition.autogenerated_definition_path;

        // is_recommended is not always specified, but it defaults to true
        const isRecommended =
          linterDefinition.is_recommended === undefined || linterDefinition.is_recommended === true;
        // good_without_config is not always specified, but it defaults to false
        const goodWithoutConfig = Boolean(linterDefinition.good_without_config);

        // Linter can be auto-enabled if one of its directConfigs is included next to its plugin.yaml
        const recommendedConfigExists =
          localRelativePath &&
          linterDefinition.direct_configs &&
          linterDefinition.direct_configs.reduce(
            (configAccumulator: boolean, directConfigFile: any) => {
              const expectedConfigPath = path.resolve(
                REPO_ROOT,
                localRelativePath,
                directConfigFile
              );

              return configAccumulator || fs.existsSync(expectedConfigPath);
            },
            false
          );

        /**
         * At present, in order to be auto-enabled without prior existence of a config, a linter must have:
         * 1. is_recommended: true (default true)
         * 2. good_without_config: true OR have a recommended direct_config to dump
         */
        if (
          Boolean(localRelativePath) &&
          isRecommended &&
          (goodWithoutConfig || Boolean(recommendedConfigExists))
        ) {
          return accumulator.concat(linterDefinition.name);
        }
        return accumulator;
      },
      []
    );

    /**
     * This is a curated list. A linter must undergo audits and dogfooding in order to be included in this list.
     * If this test is failing for a newly added linter, please set known_good_version to false or remove/rename the
     * config included in your linter subdirectory (it can be put in `test_data` and then moved during `preCheck`).
     */
    expect(autoEnabledLinters).toMatchInlineSnapshot(`
      [
        "actionlint",
        "black",
        "buildifier",
        "cfnlint",
        "clippy",
        "cue-fmt",
        "dotenv-linter",
        "flake8",
        "git-diff-check",
        "gitleaks",
        "gofmt",
        "golangci-lint",
        "hadolint",
        "haml-lint",
        "isort",
        "ktlint",
        "markdownlint",
        "nixpkgs-fmt",
        "oxipng",
        "prettier",
        "rustfmt",
        "shellcheck",
        "shfmt",
        "svgo",
        "taplo",
        "tflint",
        "yamllint",
      ]
    `);
  });
});
